```
Analyze
      Build                 vs.     Build - Measure - Learn
          Test
              Deploy
```

# Here be Dragons!

There's something about the start of a project, a blank page, that moment when you go: File > New.  Together with the beauty, the nothingness also invokes, fear.  Fear of uncertainty.  The start of a project is when we know the least.  Surely, we can't be building software in such a state of unknown?  What is needed is a way to eliminate uncertainty before we start, right?  The traditional and maybe most intuitive approach is to analyze before you start.  Analyze all the things and carefully map out a plan.  Uncertainty has been eliminated and out pops a cost, a time and a nifty Gantt chart.  A stock take at this moment usually reveals a stack of documents and three months worth of invoices.

# Before the ink is dry

The traditional approach works.  Wait, what?  Time to quote Game of Thrones:  *"You know, my brother once told me that nothing someone says before the word "but" really counts"* ~ Benjen Stark.  The traditional approach works, but... only if nothing changes.  And as we all know, before the ink on that shiny functional spec is dry, the dragon of change is set loose, and with its swooping wings lays waste to your analysis.  Even if we could wield the sword and slay the dragon of change, the traditional approach to analysis has another detractor.  Warning, the following might evoke painful memories, parental guidance is advised.

# Enter the dragons

The three months analysis phase has just completed, it's time to transform ink into code.  With the safety of the functional spec beside you, you start churning out working software.  And then, that iceberg moment.  "This won't work according to plan?  Didn't analysis erase all uncertainty?"  Your minds picture of the project manager's worried face is enough to convince you to park this thought somewhere between "not my problem" and "who's to blame".  You balance a hack with sticking to the spec and pass the code on to be tested, only to discover another iceberg, argh, more uncertainty, how is this possible?!  At least there's still loads of time before the demo.  At the demo there will be no questions, it will be exactly what everyone wanted.  That's not quite how the story ends, is it?  Coding, testing, demo and the whole act of delivering software always brings with it more learning.

# How to train your Dragon

So, on the one hand change renders our analysis waste and on the other, valuable learnings emerge only when it's too late.  But both change and learnings aren't evil, they're your friends, and they can be trained.  The solution is easy to execute, it's the change of mind that's hard to accept.  It's time for a change of start.  Get rid of distinct phases and realize that analysis, coding, testing and demo are all too integrated and part of delivery to keep apart.  Just start, code, test, demo and have those learnings emerge sooner.  Building without analysis isn't waste, analysis without build is waste.  You won't be doing no analysis, you will be doing better analysis, absolutely implement all the analysis you've always done, but don't do it in isolation, do it while delivering working software open for feedback and learning.  That's the idea, try it.
